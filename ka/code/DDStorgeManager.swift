//
//  GDStorgeManager.swift
//  zjlao
//
//  Created by WY on 17/11/18.
//  Copyright ¬© 2017Âπ¥ com.16lao.zjlao. All rights reserved.
//
public func mylog <T>(_ message: T, fileName: String = #file, methodName: String = #function, lineNumber: Int = #line){
    #if DEBUG
    let  url = URL.init(fileURLWithPath: fileName)
    
    print("‚úÖ\(url.lastPathComponent)[\(lineNumber)]:üëâ\(message)")
    #endif
}
/*
 Ëé∑ÂèñÂéÜÂè≤Ê∂àÊÅØÈÄªËæëÊ≠•È™§ :
 1.1 , ÂΩìÊúçÂä°Âô®Ê≤°ÊúâËÅäÂ§©ÂéÜÂè≤ ,Â∞±Ê†áËÆ∞noServerMessage , Âè™Êìç‰ΩúÊú¨Âú∞Êï∞ÊçÆ
 1.2 , ÂΩìÊúçÂä°Âô®Êúâ‰∫ÜËÅäÂ§©ÂéÜÂè≤ ,Ê†áËÆ∞hadServerMessage , Á¨¨‰∏ÄÊ¨°ËøõÂÖ•ËÅäÂ§©ÁïåÈù¢Â∞±ËØ∑Ê±Ç‰∏ÄÊ¨°Êé•Âè£ , ‰ª•Ëé∑Âèñ‰∏Ä‰∏™ÊúÄÂ∞èÁöÑÊ∂àÊÅØid , Âπ∂‰øùÂ≠òminMessageID
 1.3 , Â¶ÇÊûúÊú¨Âú∞Â≠òÊ∂àÊÅØ , ‰∏ÄÂÆöË¶Å‰øùËØÅÊúâÂáÜÁ°ÆÁöÑÊúÄÂ∞èsort_keyÂØπÂ∫îÁöÑÊ∂àÊÅØid
 2.1 , ÊØèÊ¨°‰∏äÊãâÂà∞‰∏äÈôê‰ª•Âêé , Áî®minMessageIDÂéªËØ∑Ê±ÇÊúçÂä°Âô®ÂéÜÂè≤Ê∂àÊÅØ Âπ∂ÊèíÂÖ•Êï∞ÊçÆÂ∫ì
 3.1 , ‰ª•ÂêéÂÜçËøõÂÖ•ËÅäÂ§©ÁïåÈù¢ , ÊúÄÂ∞èÁöÑsort_keyÂØπÂ∫îÁöÑserverID‰∏ÄÂÆöÊúâÂÄº(ÈùûÁ©∫) , Â∞±ÊãøÂÆÉÊù•ÂéªÊúçÂä°Âô®ËØ∑Ê±Ç
 
 
 1 , ÂÖà‰ªéÊï∞ÊçÆÂ∫ìÂèñ
 1,1 Êú¨Âú∞ËÉΩÂèñÂà∞Â∞±Âä†ËΩΩ , ÂèñÂà∞ÊúÄÂêé‰∏ÄÊù°Êó∂ÂÜç‰ªéÁΩëÁªúËé∑ÂèñËÅäÂ§©ËÆ∞ÂΩïÂπ∂ÊèíÂÖ•Êï∞ÊçÆÂ∫ì , ÂÜçÊé•ÁùÄ‰ªéÊï∞ÊçÆÂ∫ìËØªÂèñÂπ∂Â±ïÁ§∫ , Êñ∞ÁöÑËÅäÂ§©ËÆ∞ÂΩïÊ≠£Â∏∏ÊèíÂÖ•Êï∞ÊçÆÂ∫ì
 1.2 Êú¨Âú∞Âèñ‰∏çÂà∞ÁöÑËØù , Â∞±ÂéªÁΩëÁªúËé∑ÂèñËÅäÂ§©ËÆ∞ÂΩïÂπ∂ÊèíÂÖ•Êï∞ÊçÆÂ∫ì , ÂÜç‰ªéÊï∞ÊçÆÂ∫ìËØªÂèñÂπ∂Â±ïÁ§∫ , Êñ∞ÁöÑËÅäÂ§©ËÆ∞ÂΩïÊ≠£Â∏∏ÊèíÂÖ•Êï∞ÊçÆÂ∫ì
 1.3 Êú¨Âú∞Âèñ‰∏çÂà∞ , ÊúçÂä°Âô®‰πüÂèñ‰∏çÂà∞ÁöÑËØù , Êñ∞ÁöÑËÅäÂ§©ËÆ∞ÂΩï‰∏çÂÅöÊï∞ÊçÆÂ∫ìÂ≠òÂÇ®
 */

import UIKit
import FMDB
/// Â≠òÂÇ®Á±ª
class DDStorgeManager: UserDefaults {
    //MARK:Âçï‰æã
    static  let share : DDStorgeManager  = {
        let tempShare  = DDStorgeManager.init()
        return tempShare
    }()
    var dbPath : String {
        let dbName = "LocalDB"
        let libraryDirectoryPath  = NSSearchPathForDirectoriesInDomains(FileManager.SearchPathDirectory.libraryDirectory, FileManager.SearchPathDomainMask.userDomainMask, true ).first!;
        let dbPath = libraryDirectoryPath.appending("/\(dbName).db")
        mylog(dbPath)
        return dbPath
    }
    lazy var dbQueue : FMDatabaseQueue? = {
        return FMDatabaseQueue.init(path: self.dbPath)
        }()
    func createTable(SQLSentence:String)  {
        gotCurrentDBQueue().inDatabase({ (db) in
            let isMessageSuccessOption =  (db.executeStatements(SQLSentence))
            if(isMessageSuccessOption){
                mylog("Âª∫Ë°®ÊàêÂäü:\(SQLSentence)")
            }else{
                mylog("Âª∫Ë°®Â§±Ë¥•:\(SQLSentence)")
            }
            
        })
    }
    
    
    func deleteDB( callBack:@escaping ((_ isSucess:Bool ,_ resultStr : String)->())) -> () {//done
        do {
            try FileManager.default.removeItem(atPath: dbPath)
            mylog("Êñá‰ª∂Âà†Èô§ÊàêÂäü")
            callBack(true,"Êñá‰ª∂Âà†Èô§ÊàêÂäü")
        } catch  {
            mylog("Êñá‰ª∂Âà†Èô§Â§±Ë¥•\(error)")
            callBack(false,"Êñá‰ª∂Âà†Èô§Â§±Ë¥•")
        }
    }
 
}


///about sign
extension DDStorgeManager{
    
    func insertOrUpdate(timeStamp:TimeInterval)   {
        self.createSignTable()
        let set = Set([Calendar.Component.year , Calendar.Component.month ,Calendar.Component.day,Calendar.Component.weekday])
        let a = Calendar.current.dateComponents(set, from: Date(timeIntervalSince1970: timeStamp))
        let year = "\(a.year ?? 0)"
        let month = "\(a.month ?? 0)"
        let day = "\(a.day ?? 0)"
        let weakDay = "\(a.weekday ?? 0)"
        
        
        
        let que = self.dbQueue
        let  sqlContact = "select * from  sign_table where year = \(year) and month=\(month) and day=\(day)"
        //"select max(age) maxAge from workTable"
        //"select min(age) minAge from workTable"
        var whetherExistDate = false
        que?.inDatabase({ (db) in
            
            let result = db.executeQuery(sqlContact, withParameterDictionary: nil )
            while(result?.next() ?? false){
                whetherExistDate = true
            }
            result?.close()
        })
        
        if whetherExistDate {//Â≠òÂú®,Êõ¥Êñ∞Á≠æÈÄÄ
            let  updateSql = "update  sign_table set signout_time_stamp=\(timeStamp) ,weak_day=\(weakDay) where year = \(year) and month=\(month) and day=\(day)"
            que?.inDatabase({ (db) in
                let isContactSuccessOption =  (db.executeStatements(updateSql))
                if(isContactSuccessOption){
                    mylog("Êõ¥Êñ∞ÊàêÂäü")
                }else{
                    mylog("Êõ¥Êñ∞Â§±Ë¥•")
                }
            })
        }else{//‰∏çÂ≠òÂú®,Êó©‰∏äÁ≠æÂà∞
            let  insertSql = "insert into  sign_table(year,month,day,weak_day,signin_time_stamp)values(\(year),\(month),\(day),\(weakDay), \(timeStamp)  )"
            que?.inDatabase({ (db) in
                let isContactSuccessOption =  (db.executeStatements(insertSql))
                if(isContactSuccessOption){
                    mylog("ÊèíÂÖ•ÊàêÂäü")
                }else{
                    mylog("ÊèíÂÖ•Â§±Ë¥•")
                }
            })
        }
//        mylog(whetherExistDate)
        
        
    }
    func deleteRow(signin:TimeInterval,signout:TimeInterval)  {
        let que = self.dbQueue
        let  sqlContact = "delete from  sign_table where signin_time_stamp= \(signin)  and signout_time_stamp=\(signout)"
        que?.inDatabase({ (db) in
            let isContactSuccessOption =  (db.executeStatements(sqlContact))
            if(isContactSuccessOption){
                mylog("Âà†Èô§ÊàêÂäü")
            }else{
                mylog("Âà†Èô§Â§±Ë¥•")
            }
        })
    }
    func refreshDB()  {
        
    }
    func readTodaySignDate() -> (signin:TimeInterval,signout:TimeInterval) {
        let set = Set([Calendar.Component.year , Calendar.Component.month ,Calendar.Component.day,Calendar.Component.weekday])
        let a = Calendar.current.dateComponents(set, from: Date())
        let year = "\(a.year ?? 0)"
        let month = "\(a.month ?? 0)"
        let day = "\(a.day ?? 0)"
        
        let que = self.dbQueue
        let  sqlContact = "select * from  sign_table where year=\(year) and month=\(month) and day = \(day)"
        var signin :TimeInterval = 0.0
        var signout :TimeInterval = 0.0
        //"select max(age) maxAge from workTable"
        //"select min(age) minAge from workTable"
        que?.inDatabase({ (db) in
            let result = db.executeQuery(sqlContact, withParameterDictionary: nil )
            while(result?.next() ?? false){
                
                //                mylog(result?.int(forColumnIndex: 0))
                signin = result?.double(forColumn: "signin_time_stamp") ?? 0.0
                signout = result?.double(forColumn: "signout_time_stamp") ?? 0.0
            }
            result?.close()
        })
        return (signin:signin,signout:signout)
    }
    func readTotalSignDate(year:String? = nil , month:String? = nil) -> [(signin:TimeInterval,signout:TimeInterval)] {
        let que = self.dbQueue
        var  sqlContact = "select * from  sign_table order by signin_time_stamp desc"
        if year != nil && month != nil {
            sqlContact = "select * from  sign_table where year=\(year!) and month=\(month!) order by signin_time_stamp  desc"
        }else if year != nil {
            sqlContact = "select * from  sign_table where year=\(year!) order by signin_time_stamp desc"
        }
        
        var signin :TimeInterval = 0.0
        var signout :TimeInterval = 0.0
        //"select max(age) maxAge from workTable"
        //"select min(age) minAge from workTable"
        var timeArr = [(signin:TimeInterval,signout:TimeInterval)]()
        que?.inDatabase({ (db) in
            let result = db.executeQuery(sqlContact, withParameterDictionary: nil )
            while(result?.next() ?? false){
                signin = result?.double(forColumn: "signin_time_stamp") ?? 0.0
                signout = result?.double(forColumn: "signout_time_stamp") ?? 0.0
                timeArr.append((signin: signin, signout: signout))
            }
            result?.close()
        })
        return timeArr
    }
    func insertSignRow(timeStamp:TimeInterval)  {
        self.createSignTable()
        let set = Set([Calendar.Component.year , Calendar.Component.month ,Calendar.Component.day,Calendar.Component.weekday])
        let a = Calendar.current.dateComponents(set, from: Date(timeIntervalSince1970: timeStamp))
        let year = "\(a.year ?? 0)"
        let month = "\(a.month ?? 0)"
        let day = "\(a.day ?? 0)"
        let weakDay = "\(a.weekday ?? 0)"
        let que = self.dbQueue
        let  sqlContact = "insert into  sign_table(year,month,day,weak_day,signin_time_stamp)values(\(year),\(month),\(day),\(weakDay) , \(timeStamp) )"
        
        que?.inDatabase({ (db) in
            let isContactSuccessOption =  (db.executeStatements(sqlContact))
            if(isContactSuccessOption){
                mylog("ÊèíÂÖ•ÊàêÂäü")
            }else{
                mylog("ÊèíÂÖ•Â§±Ë¥•")
            }
        })
    }
    
    func createSignTable()  {
        //        let que  = FMDatabaseQueue.init(path: dbPath)
        let que = self.dbQueue
//        let  sqlContact = "CREATE TABLE IF NOT EXISTS sign_table(id INTEGER PRIMARY KEY AUTOINCREMENT ,date INTEGER, time_stamp INTEGER )"
                let  sqlContact = "CREATE TABLE IF NOT EXISTS sign_table(id INTEGER PRIMARY KEY AUTOINCREMENT ,year INTEGER,month INTEGER,day INTEGER,weak_day INTEGER, signin_time_stamp INTEGER , signout_time_stamp INTEGER )"
        
        que?.inDatabase({ (db) in
            let isContactSuccessOption =  (db.executeStatements(sqlContact))
            if(isContactSuccessOption){
                mylog("Âª∫Á´ãsign_tableË°®ÊàêÂäü")
            }else{
                mylog("Âª∫Ë°®sign_tableÂ§±Ë¥•,ÈáçÂ§çÂàõÂª∫")
            }
        })
    }

}
///test
extension DDStorgeManager{
    
    //////////////////////////////////////////////////////
    func gotCurrentDBQueue() -> FMDatabaseQueue {
        //        let que  = FMDatabaseQueue.init(path: dbPath)
        let que = self.dbQueue
        let  sqlContact = "CREATE TABLE IF NOT EXISTS sign_table(id INTEGER PRIMARY KEY AUTOINCREMENT ,date varchar(255), time_stamp INTEGER )"
        
        que?.inDatabase({ (db) in
            let isContactSuccessOption =  (db.executeStatements(sqlContact))
            if(isContactSuccessOption){
                mylog("Âª∫Á´ãContactË°®ÊàêÂäü")
            }else{
                mylog("Âª∫Ë°®ContactÂ§±Ë¥•,ÈáçÂ§çÂàõÂª∫")
            }
        })
        return que!
    }
    
    
    
    
    func sqlSentenceTest() {
        let  SQLStr = "insert into message (full_message_xml, other_account ,my_account, time_stamp , body , server_id ,local_id ,from_account ,to_account , sort_key ) values (?,?,?,?,?,?,?,?,?,?)"
        let delete = "delete from contact where other_account = '\("userName")'"
        let select = "select *   from message  group by other_account HAVING max(time_stamp) order by time_stamp DESC"
        let update = "update message set server_id = '\("serverID")' where local_id = '\("localID")'"
    }
    /*
     func gotCurrentDBQueue() -> (FMDatabaseQueue) {
     let que  = FMDatabaseQueue.init(path: dbPath)
     
     let  sqlContact = "CREATE TABLE IF NOT EXISTS contact(id INTEGER PRIMARY KEY AUTOINCREMENT ,last_message varchar(255),my_account varchar(255),other_account varchar(255) , time_stamp int , server_id varchar(32) , local_id varchar(32) , has_read int NOT NULL DEFAULT '0',from_account varchar(255))"
     
     let  sqlMessage = "CREATE TABLE IF NOT EXISTS message(id INTEGER PRIMARY KEY AUTOINCREMENT ,full_message_xml varchar(255),body varchar(255),my_account varchar(255),other_account varchar(255) , time_stamp int , server_id varchar(32) , local_id varchar(32) , has_read int NOT NULL DEFAULT '0',send_success int NOT NULL DEFAULT '1', from_account varchar(255)  ,  to_account varchar(255), sort_key int) ";
     que?.inDatabase({ (db) in
     let isContactSuccessOption =  (db.executeStatements(sqlContact))
     if(isContactSuccessOption){
     mylog("Âª∫Á´ãContactË°®ÊàêÂäü")
     }else{
     mylog("Âª∫Ë°®ContactÂ§±Ë¥•,ÈáçÂ§çÂàõÂª∫")
     }
     })
     que?.inDatabase({ (db) in
     let isMessageSuccessOption =  (db.executeStatements(sqlMessage))
     if(isMessageSuccessOption){
     mylog("Âª∫Á´ãMessageË°®ÊàêÂäü")
     }else{
     mylog("Âª∫Ë°®MessageÂ§±Ë¥•,ÈáçÂ§çÂàõÂª∫")
     }
     }
     )
     return que!
     }
     */
}
